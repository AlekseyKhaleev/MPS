#ifndef CONFIG_H
#define CONFIG_H

// Параметры поведения программы Analiser
// и некоторые исправления ошибок (с описаниями самих ошибок)

// Copyright (C) VAN (2006-2012)

// Все изменения можно выключить, закомментировав соответствуюший #define

// Вывод уровней сигналов при работе схемы (как в модели Ламовского)
// Может замедлить работу программы
#define DRAW_SIGNAL_LEVELS    

// "Системный генератор" работает в отдельном потоке
// Если макрос WORK_MUTUAL_EXCLUSION определен,
// добавляется взаимное исключение в TSystemGenerator::Execute()
// и других методах, например в TSchema::KeyPressed()
// Это должно убрать возможные ошибки соревнования 
#define WORK_MUTUAL_EXCLUSION

// Этот fix запрещает вызывать метод KeyPressed() во время
// работы методов GetProperty(), MouseDown(), MouseUp()
// (т.к. они могут создавать свои диалоговые окна и 
// обрабатывать события клавиатуры)
// Иначе, например, ключи реагируют на нажатия кнопок
// во время правки свойств элементов
#define FIX_KEYPRESS_WHILE_EVENT_HANDLING

// Исправление ошибки в ~TKey() в плагине instruments
// (иногда происходило повторное освобождение блока памяти)
#define FIX_KEY_DTOR

// В оригинале не сохранялись коды используемых клавиш для TKey
// Если макрос ниже определен, они будут сохраняться и загружаться
// Совместимость со старыми файлами схем сохранена
#define FIX_KEY_SAVE_KEYCODE

// Win32 Programmer's Reference: следует вызвать GdiFlush()
// после прорисовки на контексте устройства, если он
// используется несколькими потоками
#define FIX_DRAW_GDIFLUSH

// Если этот макрос определен, элемент с измененными свойствами
// перерисовывается после изменения (в оригинале этого не было)
#define FIX_DRAW_AFTER_EDITING

// Этот fix заставляет программу обходиться без временного образа tmpBmp
// Это корректирует проблемы с изменением УГО активным элементом
// (Analiser о таких изменениях ничего не знает и перерисовывает старый УГО)
#define FIX_DRAW_NO_TMPBMP

// Системный генератор должен в любом случае
// вызывать Sleep(), даже если интервал "сна" равен нулю
// (это освобождает остаток кванта времени), это 
// слегка снизит загрузку ЦП
#define FIX_SYSGEN_RELEASE_TIMESLICE

// Период вызова Sleep()
// Чем меньше это значение, тем меньше загрузка ЦП,
// однако тем медленнее работает эмулятор (незначительно)
// В оригинале было 10
#define FIX_SYSGEN_SLEEP_INTERVAL 100

// TSystemGenerator::Execute()
// При обработке очереди Execute вызываются текущие 
// зарегистрированные функции (от последней к первой)
// Если эти функции меняют значения сигналов в схеме,
// могут добавиться новые запросы в очередь Execute
// В исходном варианте очередь очищалась и новые запросы
// пропадали, что приводило к некорректным результатам
#define FIX_SYSGEN_EXECUTE_QUEUE

// Нужно сбросить значения ChangeKind для всех контактов
// перед началом моделирования. Иначе при повторном "включении"
// могут наблюдаться некорректные результаты
// Также устанавливает направление (Kind) для контактов, равное
// определенному в шаблоне
#define FIX_CORE_INIT_PINS

// Почему-то TCanvas::BrushCopy() работает намного лучше TCanvas::Draw()
// При использовании последней функции битовые образы
// не рисовались через некоторое время (не сразу!)
// Где-то есть ошибка соревнования ?
#define FIX_UPDATE_DRAW

// Значение сигнала на не подключенном ни к чему контакту
// 0 = 0, 1 = 1, 2 = Z
// Если макрос не определен, возвращается исходное поведение эмулятора
// (т.е. при уничтожении соединения на контакте остается предыдущий уровень..
#define FIX_ORPHAN_PIN_VALUE 2

// Уровень сигнала "Z" - это звучит несколько странно :)
// Здесь указывается, как трактовать Z на контактах 
// По умолчанию (если макрос не определен), считается нулем,
// это исходное поведение эмулятора. 
#define FIX_LOGIC_Z_VALUE false

// В классе TConst (элементы "1" и "0") добавится
// метод StartModel()
#define FIX_CONST_STARTMODEL

// Устраняет редкие проблемы с прорисовкой новых элементов
// (в Element.cpp не совсем корректно задавались установки 
// прозрачности для образов УГО)
#define FIX_ELEMENT_BITMAP_TRANSPARENT

// В реализации ОЗУ (TRAM в SimpleDigital.dll) есть ошибка:
// при нажатии правой кнопки на элементе выводится меню, 
// однако плагин неправильно выставляет адреса обработчиков
// команд меню. В результате получается, что редактировать
// можно только последнее созданное ОЗУ, а если его уничтожить,
// можно наблюдать весьма интересные эффекты ;)
// Этот fix устраняет проблему
#define FIX_MEMORY_POPUP

// Счетчик с параллельной загрузкой (TLoadCounter в SimpleDigital.dll)
// неправильно интерпретирует уровень на входе R (инверсном на УГО,
// однако сброс происходит при ВЫСОКОМ уровне на нем)
#define FIX_LOADABLE_COUNTER_R

// Исправление неправильной загрузки в TLoadCounter
#define FIX_LOADABLE_COUNTER_LOAD

// Сразу после включения триггеры оказываются в непонятном состоянии
// (Q и не-Q равны нулю одновременно)
// Этот fix устраняет проблемы
#define FIX_FLIPFLOPS

// Ошибка при сдвигах в регистре, когда выходы отключены (W=0)
#define FIX_REGISTER

// Добавляет взаимное исключение в осциллографе (Instruments.dll)
// Кроме того, в реализации осциллографа была исправлена другая ошибка - мертвые блокировки
// (почти все методы и свойства компонентов VCL должны использоваться главным 
// потоком... Для этого прямые обращения к ним были заменены на вызовы AddSynchronizedCall())
#define FIX_OSC_MUTUAL_EXCLUSION

// Добавляет взаимное исключение в отладчике i8080
// и устраняет мертвые блокировки в нем же
#define FIX_CPU_MUTUAL_EXCLUSION

// Отладчик i8080 в своем исходном варианте не показывал 
// изменяющиеся значения регистров
#define FIX_CPU_DEBUGGER_UPDATE_REGS

// Некорректно реализована команда shld
#define FIX_CPU_SHLD

// Некорректная работа триггера разрешения прерываний
// Команды EI и DI выдают сигнал на вывод INTE, но не меняют
// значение переменной INTES, которая анализируется при 
// приходе INT
#define FIX_CPU_INTE

// Опечатка в реализации команды ANI
#define FIX_CPU_ANI

// В оригинале не было команды rar и неправильно реализованы rlc и rrc
#define FIX_CPU_SHIFTS

// Пересчет признаков не должен происходить всегда
// (только тогда, когда меняется A)
#define FIX_CPU_DAA

// Опечатка в реализации LDA
#define FIX_CPU_LDA

// Команда DAD должна иметь необычно длинный цикл M1 - 10 тактов
// (проверено на реальном ЦП)
// Обычный M1 выполняется за 4 такта - добавляем еще 6
#define FIX_CPU_DAD_DUTY_CLOCKS 6

// При получении при прерывании команды CALL
// процессор должен генерировать три цикла INTA,
// а не INTA и два MRD
// CPU не принимает при прерывании команды, отличные
// от RST и CALL
#define FIX_CPU_INTA 

// При захвате HLDA переходил в активный уровень аж в четвертом такте 
// фронту F2. А должен в третьем по фронту F1
#define FIX_CPU_HLDA 

// WAIT должен устанавливаться по фронту F1, а не F2
#define FIX_CPU_HALT

// Цикл INTA состоит из трех тактов. Должен состоять из пяти
// Этот макрос показывает, сколько пустых тактов добавить
#define FIX_CPU_INTA_DUTY_CLOCKS 2

// Модифицация указателя стека должна производиться до проталкивания в 
// стек, а не после. Извлечение - в обратном порядке
#define FIX_CPU_SP_CHANGE_ORDER

// Некорректная работа RESET (в первом цикле M1 после сброса
// не выводился байт состояния M1)
#define FIX_CPU_RESET

// Команда CPI - двухбайтовая
// Второй байт считывался, но PC не увеличивался,
// в результате чего этот же байт считывался как КОП в следующем M1
#define FIX_CPU_CPI

// Системный контроллер вырабатывает упреждающие сигналы
// чтения, однако иногда после чтения памяти сам же забивает
// шину данных лишней информацией...
#define FIX_SC_PREFETCH

// Не совсем правильная реакция на HLDA - системный контроллер
// из-за ошибки делает HLDA выходом (!) при фронте на нем,
// поэтому срез HLDA не воспринимается вообще...
#define FIX_SC_HLDA

// Разрешить вывод окна отладки для ВВ55
#define FIX_BB55_DEBUG_WINDOW

// В исходном варианте свойства ChangeKind после использования не сбрасывались!
// (Некоторые из них должны были сохраняться между вызовами Execute(),
// однако остальные - нет.)
// Ядро программы этого не делает, это должен выполнять сам плагин
// Здесь это приводит к некорректной работе
#define FIX_BB55_CHANGEKIND

// CS интерпретируется слегка некорректно
#define FIX_BB55_CS

// Считывание значений с шины данных D0-D7 и KA/KB/KC происходит в обратном порядке!
// (считанные разряды в полученных числах имеют обратный порядок)
// Этот fix заставляет считывать данные правильно
#define FIX_BB55_READDB

// Для записи ситуация аналогичная...
#define FIX_BB55_WRITEDB

// Ошибка при обработке чтения из KB в режиме 1 
#define FIX_BB55_KB_MODE1

// Ошибка работы KA в режиме 2
#define FIX_BB55_MODE2

// Строб записи в режиме 1 должен переходить в неактивный уровень
// при переходе сигнала подтверждения в активный уровень, а не раньше...
// (материалы Интернета)
#define FIX_BB55_MODE1_OUT_BEHAVIOR

// Некорректная реализация слова состояния буфера FIFO ВВ79
#define FIX_BB79_STATUS_WORD

// Новая реализация для переключателя
// В отличие от старой, новый ключ действительно двунаправленный
// Платой за это является потеря скорости (старая реализация более быстра)
#define FIX_NEW_KEY_IMPL

// Эта "примочка" заставляет Analiser сортировать меню плагинов
#define TWEAK_SORT_MENU_ITEMS

// Максимальная длина ID на шине. В оригинале была равна 3...
#define TWEAK_MAX_ID_LENGTH 255

// Начальное значение уровня на контакте. Используется в TPin::TPin()
#define VALUE_INITIAL_PIN_SIGNAL LowSignal

// Значения логических уровней по умолчанию
#define VALUE_DEFAULT_HIGH_LEVEL 3
#define VALUE_DEFAULT_LOW_LEVEL  0
#define VALUE_DEFAULT_THRESOLD   1.5

// Разрешение вывода отладочных сообщений при работе программы
// в файл debug.log
//#define DEBUG_VERSION

// По умолчанию предупреждения выводятся в debug.log даже при выключенной
// отладке. Если этот макрос определен, все макросы WARN()
// раскрываются в пустую строку
//#define DISABLE_WARNINGS

#pragma warn -8057

//-------------------------------------------------------------------------
// Различные служебные макросы

// Макрос для индексации списков типа TList
#define ITEM(listpointer,index,type) ((type*)(listpointer)->Items[index])

#define LISTPTR(listpointer,type) ((type**)((listpointer)->List))

// Этот макрос можно использовать для автоматического вызова заданного
// метода foo объекта obj с аргументами args при выходе из текущего блока
// Например: CALL_AT_EXIT(TMyClass, *this, myfunc, (ref.a,ref.b,ref.c))
// Название используемой структуры должно быть уникальным ;)
#define CALL_AT_EXIT(objtype,obj,foo,args)                      \
struct __call_at_exit_struct##_##foo##_##objtype {              \
 objtype &ref;                                                  \
 __call_at_exit_struct_##foo##_##objtype(objtype &p):           \
  ref(p) {;}                                                    \
~__call_at_exit_struct_##foo##_##objtype() {ref.foo##args;}     \
} __call_at_exit_struct_##foo##_##objtype##_inst(obj);

// Макрос для создания и автоматического уничтожения 
// объектов классов стиля VCL (должны создаваться с помощью new)
#define DYNAMIC_OBJECT(type,ptrname,args)                       \
type *ptrname = new type##args;                                 \
struct __auto_destroy_##ptrname {                               \
 type *p;                                                       \
 __auto_destroy_##ptrname(type *xp): p(xp) {;}                  \
~__auto_destroy_##ptrname() {delete p;}                         \
} __auto_destroy_##ptrname##_inst(ptrname);

#define DYNAMIC_ARRAY(type,ptrname,size)                        \
type *ptrname = new type[size];                                 \
struct __auto_destroy_##ptrname {                               \
 type *p;                                                       \
 __auto_destroy_##ptrname(type *xp): p(xp) {;}                  \
~__auto_destroy_##ptrname() {delete [] p;}                      \
} __auto_destroy_##ptrname##_inst(ptrname);

template <class X>
class TAutoDelete {
public:
 TAutoDelete(X *p): ptr(p) {;}
~TAutoDelete() {delete ptr;}
protected:
 X *ptr;
};

#include <typeinfo>
#include "logger.h"
#include <windows.h>

# define DEBUG_LOG_INITIALIZE                                         \
		 TOrdinaryLogger logger;                                      \
		 ILogger *debuglog = &logger;                                 \
		 ILogger *__declspec(dllexport) GetLogger() {return &logger;}

# define DEBUG_LOG_INITIALIZE_IMP                                     \
         ILogger *debuglog = GetLogger();

extern ILogger *debuglog;
extern ILogger *GetLogger();

// Определения макроса TRACE
#if defined(DEBUG_VERSION)
# define TRACE(str) ((*debuglog) << GetSysGenTime() \
                     << " [" << (int)GetCurrentThreadId() << "]: " << str, debuglog->Endl())
#else
# define TRACE(str)
#endif

#if defined(DISABLE_WARNINGS)
# define WARN(str) 
#else
# define WARN(str) ((*debuglog) << "[!!!] " << GetSysGenTime() << ": " << str, debuglog->Endl())
#endif

#endif

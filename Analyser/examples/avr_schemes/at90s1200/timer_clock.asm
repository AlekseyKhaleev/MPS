; Тестирование работы таймера, прерывания по переполнению таймера
; Здесь реализованы простейшие часики с использованием таймера
; Это файл описания внутренностей выбранного микроконтроллера
.include "1200def.inc"

; Сегмент кода
.cseg

; В самом начале программы всегда лежат вектора прерываний, за исключением случая, когда прерывания не используются
; Вектор прерывания - это адрес, указывающий на начало соответствующего обработчика прерывания
; Обработчик прерывания - это функция, вызываемая при возникновении прерывания
.org 0					; Переходим в начало памяти программ
	rjmp	reset		; Переходим к обработчику прерывания "RESET"
.org OVF0addr			; Переходим к адресу вектора прерывания по переполнению таймера 0
	rjmp	tim0_ovf	; Переходим к обработчику прерывания "TIMER0_OVF"

; Обработчик прерывания "RESET"
; Как правило, здесь выполняется инициализация программы, подготовка к работе, так сказать
reset:	
	ldi	r16,0xff
	out	DDRB,r16	; Potr B turn out
	out	DDRD,r16	; Port D turn out

; Использование портов - что к чему подключено
; Port B
; ------
; PB0 - i1 - выбор индикатора 1
; PB1 - i2 - выбор индикатора 2
; PB2 - i3 - выбор индикатора 3
; PB3 - i4 - выбор индикатора 4
; PB4 - h - управление точкой на дисплее
; PB5 - enable - включение дисплея

; Port D
; ------ 
; На порт D повешены сегменты индикаторов - отдельные светодиоды
; PD0 - a
; PD1 - b
; PD2 - c
; PD3 - d
; PD4 - e
; PD5 - f
; PD6 - g

	ldi	r16,0x21	; Включаем дисплей и зажигаем первый индикатор
	out	PORTB,r16
	
	clr	r16		; Данных для отображения сначала нет
	out	PORTD,r16
	
	clr	r18		; Десятки и единицы секунд
	clr	r19		; Десятки и единицы минут
	
	ldi	r16,0x70	; Настраиваем таймер
	out	TCNT0,r16	; Указываем корректировочное значение
	ldi	r16,0x03
	out	TCCR0,r16	; Указываем коэффициент деления частоты ядра
	ldi	r16,0x02
	out	TIMSK,r16	; Разрешаем прерывание по переполению таймера (т.е. по переполнению TCNT0)
    
	sei			; Разрешение прерываний

; В этом цикле происходит просесс управления 4-мя 7-сегментными индикаторами 
; Этот цикл периодически прерывается прерыванием от таймера
main:
	in	r17,PORTB	; Узнаём какой индикатор горит в данный момент
	clr	r16
	out	PORTB,r16	; Тушим текущий горящий индикатор, иначе будут неприятные глазу наложения
	or	r16,r17   
	andi	r16,0x0f
	lsl	r16		; Смена активного индикатора
	sbrc	r16,4
	ldi	r16,0x01
	rcall	display		; Кидаем в порт D данные для отображения
	andi	r17,0xf0
	or	r17,r16		
	out	PORTB,r17	; Зажигаем следующий выбранный индикатор
	rjmp	main		; И по новой

; Функция отображения чисел на дисплее
; Здесь творится полный беспредел, в результате которого каким-то образом
;  числа все-таки находят на дисплее свои места
display:
	cpi	r16,0x01
	brne	dis_next1
	; Десятки минут
	mov	r21,r19
	swap	r21
	rjmp	display_end
dis_next1:
	cpi	r16,0x02
	brne	dis_next2
	; Единицы минут
	mov	r21,r19
	rjmp	display_end
dis_next2:
	cpi	r16,0x04
	brne	dis_next3
	; Десятки секунд
	mov	r21,r18
	swap	r21
	rjmp	display_end
dis_next3:
	; Единицы секунд	
	mov	r21,r18
display_end:
	andi	r21,0x0f
; Декодирование числа в значение дисплея
; Если бы это было на языке Си, то код,
;  написанный ниже, был бы в виде "switch() {case ...}"
	cpi	r21,0
	brne	dec_next1
	ldi	r21,0x3f
	rjmp	decoder_end
dec_next1:
	cpi	r21,1
	brne	dec_next2
	ldi	r21,0x06
	rjmp	decoder_end
dec_next2:
	cpi	r21,2
	brne	dec_next3
	ldi	r21,0x5b
	rjmp	decoder_end
dec_next3:
	cpi	r21,3
	brne	dec_next4
	ldi	r21,0x4f
	rjmp	decoder_end
dec_next4:
	cpi	r21,4
	brne	dec_next5
	ldi	r21,0x66
	rjmp	decoder_end
dec_next5:
	cpi	r21,5
	brne	dec_next6
	ldi	r21,0x6d
	rjmp	decoder_end
dec_next6:
	cpi	r21,6
	brne	dec_next7
	ldi	r21,0x7d
	rjmp	decoder_end
dec_next7:
	cpi	r21,7
	brne	dec_next8
	rjmp	decoder_end
dec_next8:
	cpi	r21,8
	brne	dec_next9
	ldi	r21,0x7f
	rjmp	decoder_end
dec_next9:
	ldi	r21,0x6f
decoder_end:
	out	PORTD,r21	; Кидаем полученный код в порт D
	ret			; Возвращаемся восвояси, прихватив с собой из стека пару байтов

; Обработчик прерывания по переполнению таймера 0
; Здесь по данным разведки КГБ происходят тайные махинации, связанные со счётом времени ;)
tim0_ovf:
	; Здесь используется BCD-формат представления десятичных чисел
	; А сделано так для того, чтобы не париться потом, в функции "display"
	inc	r18		; Инкремент единиц секунд
    
	mov	r31,r18		; Эт так, для порядка, а может и для беспорядка
	andi	r31,0x0f
	cpi	r31,0x0a	; Проверка не накопилось ли 10 секунд в единицах секунд
	brne	tim_end		; Если нет, выходим покедова из обработчика
    
	; Если в единицах секунд накопилось больше 9 секунд - выполняем следующий код
	andi	r18,0xf0	; Зачищаем единички секунд
	ldi	r20,0x10
	add     r18,r20		; Инкрементируем десятки секунд
    
	cpi	r18,0x60	; Проверка не накопилось ли 60 секунд
	brlo	tim_end		; Если нет, выходим покедова из обработчика
    
	; Если накопилось больше 59 секунд - выполняем следующий код
	clr	r18
	inc	r19
    
    mov		r31,r19		; Эт так, для порядка, а может и для беспорядка
	andi	r31,0x0f
	cpi		r19,0x0a	; Проверка не накопилось ли 10 минут в единицах минут
    brne	tim_end		; Если нет, выходим покедова из обработчика
    
    ; Если в единицах минут накопилось больше 9 минут - выполняем следующий код
    andi	r19,0xf0	; Зачищаем единички минут
    ldi		r20,0x10
    add     r19,r20		; Инкрементируем десятки минут
    
    cpi		r19,60		; Проверка не накопилось ли 60 минут
    brlo	tim_end		; Если нет, выходим покедова из обработчика
    
    ; Если накопилось больше 59 минут - выполняем следующий код
    clr		r19
    
    ; Часов нет, но не вопрос с доработкой для неособо ленивого студента! ;)
      
tim_end:
	ldi		r31,0x70	; Восстанавливаем корректировочное значение
	out		TCNT0,r31	
    reti				; Выходим из обработчика
 

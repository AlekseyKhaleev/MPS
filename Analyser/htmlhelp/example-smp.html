<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
  <title></title>
  <meta name="description" content="">
  <meta name="keywords" content="">
  <meta name="author" content="VAN">
  <meta name="generator" content="Quanta Plus">
</head>
<body>

<a name="smp"></a>
<h1>5.6. Двухпроцессорная система (cputest-smp.sch)</h1>

<p style="text-align: justify">Используя присутствующую в программе модель арбитра (модуль extra.dll), 
можно создать систему, в которой присутствует два процессора Intel 8080, 
разделяющих одну общую шину для доступа к памяти. В отличие от простой системы 
с одним активным устройством на шине (процессором), здесь ситуация осложняется 
тем, что нужно разделить время обращений к шине от активных устройств, чтобы они 
друг другу не мешали. Одного арбитра для этого недостаточно, т.к. он только 
вырабатывает сигналы разрешения доступа, но не производит никаких действий по 
отключению шин активных устройств от системной шины. Кроме того, требуется схема 
выработки управляющих сигналов для памяти и регистров портов ввода/вывода, если они есть. </p>

<p style="text-align: justify">В собранной схеме присутствуют следующие элементы:</p>

<ol>
  <li>Два процессора Intel 8080. Чтобы как-то отличить их при параллельной работе,
  старший разряд их шин адреса подключен не к процессору, а зафиксирован в одном положении («0» для одного процессора, «1» для другого), иначе они будут выполнять одну и ту же программу. В реальных системах так поступать не следует, т.к. процессоры никак не могут обратиться к одной и той области памяти. В нашем случае это не важно, т.к. мы проверяем саму возможность параллельной работы и работоспособность арбитра и схем сопровождения;</li>
  <li>Два системных контроллера ВК28 (Intel 8228) – по одному на процессор. 
  Служат для выработки управляющих сигналов и управления шиной данных;</li>
  <li>Модуль ОЗУ на 8 килобайт;</li>
  <li>4 односторонних шинных формирователя (по два на процессор) – служат 
  для подключения адресных выходов процессоров к шине адреса памяти в моменты 
  доступа к ней. В остальное время шины должны быть отключены, чтобы процессоры 
  не мешали друг другу, одновременно выставляя адрес на одну и ту же шину;</li>
  <li>Арбитр шины 74F786 – служит для распределения времени доступа к системной шине. Входные запросы формируются из сигналов чтения/записи памяти, поступающих от системных контроллеров. Выходы разрешения BG подключены к входам BUSEN системных контроллеров, что позволяет подключать локальные шины данных процессоров к памяти в нужный момент. Так же эти сигналы, пройдя через инвертор, попадают на вход READY процессоров, что дает возможность подождать, пока доступ к памяти не будет разрешен;</li> 
  <li>Также есть несколько базовых логических элементов для формирования управляющих сигналов.</li>
</ol>

<img src="images/samples/image032.png" width="887" height="1004" alt="" border="0">

<p>Временные диаграммы работы здесь следующие:</p>

<img src="images/samples/image034.png" width="612" height="173" alt="" border="0">

<p style="text-align: justify">Первые два канала осциллографа показывают состояние входов памяти 
RD и WR. Т.к. записи в память у нас нет, сигналы запроса доступа 
в шине будут совпадать с сигналами MR, приходящими от системных 
контроллеров (следующие два канала). Еще два канала показывают состояние 
сигналов ST.STB, т.е. фактически положение во времени циклов команд. 
Наконец, последние два канала – состояние выходов разрешения арбитра. </p>

<p style="text-align: justify">Видно, что при первой попытке чтения памяти оба процессора 
выставили запрос одновременно. Арбитр выбрал запрос второго 
процессора и выставил на BG2 сигнал низкого уровня. В это время 
вход READY процессора 1 неактивен, поэтому процессор ждет, пока 
ему не предоставят доступ к шине. Второй процессор в это время 
производит чтение из памяти. Наконец, доступ предоставляется первому процессору. 
</p>

<p style="text-align: justify">В дальнейшем задержки уже не наблюдаются, т.к. выполненные первым 
процессором такты ожидания привели к «разности фаз» исполнения
команд, поэтому в дальнейшем запросы не перекрывались во времени. 
Поэтому в течение последующей работы процессоры выполняли свои 
программы действительно одновременно. Т.е. шина памяти здесь не 
является узким местом, в отличие от реальных систем, где требования процессоров 
намного выше возможности памяти (что приводит к необходимости использования 
кэш-памяти процессоров).</p>

</body>
</html>
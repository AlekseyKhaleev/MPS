<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
  <title></title>
  <meta name="description" content="">
  <meta name="keywords" content="">
  <meta name="author" content="VAN">
  <meta name="generator" content="Quanta Plus">
</head>
<body>

<div style="text-align: center"><h1>2. ASM80 - Ассемблер для Intel 8080</h1></div>

<a name="invokation"></a>
<h4>2.1. Запуск</h4>

<p style="text-align: justify">Ассемблер запускается из командной строки, причем формат вызова следующий:</p>

<p align="left">
<table border="1"><tr><td bgcolor="white">
<font face="Courier New" size="-1">
asm80 исходный-файл файл-результат [-f формат] [-s размер] [-q] [-m файл-языка] [-l файл-листинга]
</td></tr></font>
</table>
</p>

<p style="text-align: justify">В квадратных скобках указаны необязательные параметры. В любом случае требуется
наличие первых двух параметров, иначе ассемблер просто выводит на экран подсказку следующего вида:
</p>

<table border="1"><tr><td bgcolor="white">
<font face="Courier New">
<pre>
ASM80 - Intel 8080 assembler & linker
Copyright (C) VAN (2007)

Usage:
asm80 source-file destination-file [-f fmt] [-s size] [-l file] [-q] [-m lang]

Where:

source-file        Asm80 source text for assembling

destination-file   Destination binary file in one of supported formats

-f format          Target format (one of following):
                   raw  - simple binary output w/o extra headers
                   dum  - old dump (*.dum) format (fixed size: 1K)
                   new  - new dump (*.dump) format (tunable size)

-s size            Size of output in bytes (for "new" format only)

-l file            Write assembly listing to specified file

-q                 Quiet mode (don't print progress messages)

-m langfile        Load message file from langfile

The default format is "raw". Default size is 1K
</pre>
</td></tr></font>
</table>


<p style="text-align: justify">При отсутствии дополнительных параметров файл, определенный параметром 
<b>«исходный-файл»</b>, ассемблируется, и результат записывается в файл-результат 
в формате без всяких заголовков (<b>raw</b>). Полученный файл можно загрузить в элемент 
памяти плагина <b>«Память, триггеры, регистры»</b> (<b>memory.dll</b>) программы моделирования 
(старая реализация памяти не умеет читать такие файлы – для нее годятся только файлы <b>dum</b>). 
</p>
 

<p align="left">Дополнительные параметры:</p>

<ol>
	<li><b>–f формат</b>. Задает формат генерируемого файла. Указываемый здесь <b>формат</b> может 
		быть одним из трех слов: <b>raw</b> («сырой», уже рассматривавшийся выше), 
		<b>dum</b> (старый формат дампов памяти – расширение <b>.dum</b>), 
		<b>new</b> (новый формат дампов – расширение <b>.dump</b>). По умолчанию используется raw.</li>
	<li><b>–s размер</b>. Указывает размер получаемого файла в байтах (без учета заголовков). 
		Если получаемый файл меньше указанного размера, он дополняется нулями до него (причем для формата <b>raw</b> это не производится). 
		Если больше, ассемблер выдает сообщение об ошибке. Если этот размер не указан, 
		он никак не учитывается (однако для <b>dum</b> он всегда равен <b>1K</b> вне зависимости от этого параметра).</li>
	<li><b>–l файл</b>. При наличии этого параметра ассемблер генерирует листинг и записывает его в <b>файл</b>. 
		Полученный текст может использоваться для изучения машинного кода и проверки ассемблера;</li>
	<li><b>–q</b>. Запрещает выводить разные некритические сообщения во время работы. Сообщения об ошибках выводятся все равно;</li>
	<li><b>–m файл</b>. Загружает указанный файл строк сообщений из <b>файла</b>. По умолчанию загружается <b>asm80-lang\en.txt</b>.</li>
</ol>

<a name="gui"></a>
<h4>2.2. Запуск из графического интерфейса</h4>

<p style="text-align: justify">При наличии плагина <b>asm80dll.dll</b> ассемблер встраивается в программу Analiser 
и может быть вызван для генерации содержимого модуля памяти прямо из 
графического интерфейса. Работу с ассемблером поддерживают элементы ОЗУ 
(ОЗУ 1К, ОЗУ 8К и двухпортовое ОЗУ) из плагина <b>«Память, триггеры, регистры»</b> (<b>memory.dll</b>). 
</p>
 
<p style="text-align: justify">Для того, чтобы вызвать ассемблер, нужно вывести на экран окно редактора 
содержимого модуля памяти (с помощью контекстного меню для элемента) 
и нажать кнопку <b>«Из плагина»</b>. В появляющемся меню нужно выбрать пункт <b>«Ассемблер ASM80»</b>. 
</p>

<div style="text-align: center"><img src="images/asm80/image001.png" width="300" height="437" hspace="12"></div>

<br><p style="text-align: justify">После этого на экране появляется окно редактора исходных текстов, в котором также можно 
запустить компиляцию и просмотреть получаемый листинг. 
</p>
 
<p>Внешний вид редактора показан на рисунке ниже.</p>

<div style="text-align: center"><img src="images/asm80/image003.png" width="637" height="411" alt="" border="0"></div>

<p>Здесь можно произвести следующие действия:</p>

<ol>
	<li>Отредактировать исходный текст с помощью соответствующего поля ввода;</li>
	<li>Загрузить файл в поле ввода;</li>
	<li>Сохранить файл;</li>
	<li>Скомпилировать файл и загрузить его в текущий модуль памяти (для которого вызывался ассемблер);</li>
</ol>

<p style="text-align: justify">Автоматически этот редактор содержимое файла не сохраняет. Это нужно сделать вручную. 
Однако при компиляции используется текущая отредактированная версия. 
</p>
 
<p style="text-align: justify">При компиляции создаются временные файлы в текущем каталоге временных 
файлов (на который указывает переменная окружения <b>TEMP</b>).
После компиляции эти файлы удаляются, а созданный дамп 
загружается в модуль памяти. Листинг можно посмотреть 
на соответствующей вкладке. 
</p>
 
<p>Есть возможность загрузки дампа с указанного смещения в модуле, а также возможность ограничения размера дампа. 
(при превышении размера ассемблер выдает соответствующее сообщение об ошибке)</p>

<a name="syntax"></a>
<h4>2.3. Синтаксис</h4>
 
<p style="text-align: justify">Каждая директива или команда ассемблера располагается в отдельной строке. 
Ассемблер может работать с объектами следующих видов, причем он не различает регистр символов:
</p>

<ol> 
<li>Числовые константы. Могут быть записаны в двоичной, восьмеричной, десятичной, шестнадцатеричной системе счисления. 
Например, следующие записи определяют одно и то же число:</li> 

<p><table border="1"><tr><td bgcolor="white">
<font face="Courier New"> 
<pre>
0ABh        ; шестнадцатеричная система
171         ; десятичная система
253o        ; восьмеричная система
10101011b   ; двоичная система</pre>
</font></td></tr></table>
</p>

<p style="text-align: justify">Суффиксы h, o, b на концах чисел как раз и определяют систему счисления. 
Для десятичной системы суффикс не указывается. </p>
</li>

<li><p style="text-align: justify">Именованные объекты (константы, метки и переменные). Ссылки на них в 
инструкциях обрабатываются ассемблером одинаково (он подставляет на фазе 
компоновки вместо имен числа – значения констант, адреса меток и переменных). 
Так как имена разрешаются на фазе компоновки, то все равно, где определены сами 
переменные или константы – их можно использовать до определения;</p> 
</li>

<li>
<p style="text-align: justify">Регистры. Можно использовать все доступные регистры <b>i8080: a, b, c, d, e, h, l, m</b> 
(последнее имя ссылается на ячейку памяти, адресуемую <b>HL</b>);</p>
</li> 

<li>
<p style="text-align: justify">Регистровые пары. На них можно ссылаться как на <b>b, d, h</b>, так и как на <b>bc, de, hl</b>;</p>
</li>

<li>
<p style="text-align: justify">Комментарии. Ассемблер поддерживает однострочные комментарии, начинающиеся с точки с запятой и продолжающиеся до конца строки. </p>
</li>

</ol> 

<p style="text-align: justify">На каждой строке текста программы может располагаться только одна директива или 
инструкция (строки могут быть и пустыми). Директивы поддерживаются следующие:
</p>
 	   
<ol>

<li>
<p style="text-align: justify">Определение значения счетчика ассемблера – директива <b>org</b>. Формат: </p>

<p><table border="1"><tr><td bgcolor="white">
<font face="Courier New" size="-1"> 
org число
</font></td></tr></table>
</p>

<p style="text-align: justify">Число здесь должно быть явным (т.е. нельзя использовать именованную константу). 
Ассемблер хранит счетчик, соответствующий текущему адресу в дампе. 
Эта директива позволяет его менять. Обычно она полезна в начале файла. Пример:
</p>

<p><table border="1"><tr><td bgcolor="white">
<font face="Courier New" size="-1"> 
org 8200h
</font></td></tr></table>
</p>
</li>

<p style="text-align: justify">
<b>Важно: </b> эта директива никак не связана со смещением, вводимым в окне редактора
ассемблерных файлов. Она лишь задает значение счетчика адреса ассемблера, а задаваемое в окне
смещение показывает, в какую область модуля памяти будет загружен дамп. Обычно число, заданное
директивой <b>org</b> и смещение для загрузки задаются одинаковыми, чтобы избежать проблем 
при адресации данных и команд (чтобы загружать с начала модуля, нужно указать <b>org 0</b>
и смещение, равное нулю). Однако это не всегда так: модули памяти могут быть подключены по-разному. 
Если, например, модуль памяти отображается на адреса, начиная с 2000h, то (при загрузке с начала модуля)
нужно использовать <b>org 2000h</b> и смещение, равное нулю.
</p>

<li>
<p style="text-align: justify">Определение константы – директива <b>const</b>. Формат: </p>

<p><table border="1"><tr><td bgcolor="white">
<font face="Courier New" size="-1"> 
const имя значение
</font></td></tr></table>
</p>
 
<p style="text-align: justify">Здесь параметр <b>имя</b> задает имя константы, а следующий параметр – ее значение, 
которое должно указываться явно (т.е. недопустимы ссылки на другие константы, переменные или метки);
</p>
 
<p>Пример:</p>

<p><table border="1"><tr><td bgcolor="white">
<font face="Courier New" size="-1"> 
const sample 123456789
</font></td></tr></table>
</p>
</li>
	
<li>
<p style="text-align: justify">Определение меток – директива <b>label</b></p>

<p><table border="1"><tr><td bgcolor="white">
<font face="Courier New" size="-1">  
label имя
</font></td></tr></table>
</p>

<p style="text-align: justify">Создает метку с указанным именем и адресом, равным текущему значению счетчика 
адреса ассемблера. Метка может быть создана также другим способом, см. пример:
</p>

<p><table border="1"><tr><td bgcolor="white">
<font face="Courier New"><pre>
label proc1       ; Эти две строки делают одно 
:proc1            ; и то же
</pre></font></td></tr></table>
</p>
</li>

<li>
<p style="text-align: justify">Определение переменных – директивы <b>db</b> (выделить байт) и <b>dw</b> (выделить двухбайтовое слово) </p>
 
<p><table border="1"><tr><td bgcolor="white">
<font face="Courier New"><pre>
[имя] db [значение1 [, значение2, значение3...]]
[имя] dw [значение1 [, значение2, значение3...]
</pre></font></td></tr></table>
</p>

<p style="text-align: justify">Создает переменную с заданным именем и типом (байт/слово). Можно выделить сразу 
несколько инициализирующих значений (в этом случае будет выделено несколько 
байт или слов). В директиве <b>db</b> можно указывать строковые инициализаторы. 
Кроме того, можно указывать имена других переменных, меток (будут подставлены 
их адреса) или констант (будут подставлены значения). 
</p>
 
<p style="text-align: justify">Если имя не указано, будут просто выделены неименованные байты/слова 
с указанным содержимым. Если не указаны инициализаторы, 
создается один байт/слово с нулевым содержимым.
</p>
 
<p>Пример:</p>

<p><table border="1"><tr><td bgcolor="white">
<font face="Courier New"><pre>
        db 0ffh
test    db 1h, 2h, 3h, 10o, 1010b, 'this is a test', 10
test2   dw test, c1
hl1     dw test_proc
hl2     dw
hl3     dw 01000h
</pre></font></td></tr></table>
</p>
</li>

<li>
<p style="text-align: justify">Резервирование памяти – директива <b>dr</b>: </p>

<p><table border="1"><tr><td bgcolor="white">
<font face="Courier New" size="-1">  
[имя] dr число-байт [, содержимое]
</font></td></tr></table>
</p>
 
<p style="text-align: justify">Позволяет выделить именованную или неименованную область памяти, 
заполненную байтами заданного содержимого. Если содержимое не указано, область заполнена нулями.
</p>
</li> 

<li>
<p style="text-align: justify">Перемещение к заданному адресу – директива <b>skip</b>: </p>

<p><table border="1"><tr><td bgcolor="white">
<font face="Courier New" size="-1">  
skip адрес [, заполнитель]
</font></td></tr></table>
</p>

<p style="text-align: justify">Эта директива пишет в выходной файл заданные байты заполнителя (нули по умолчанию) 
до тех пор, пока значение счетчика адреса ассемблера не достигнет значения <strong>адрес</strong>. 
Удобно использовать директиву <b>skip</b> в тех случаях, когда нужно расположить код или 
данные по заданному адресу. Однако нет возможности переместиться к адресу меньше текущего.
</p>
</li>
</>

<p style="text-align: justify">Пример (см. схему <b>memtest.sch</b> – тест памяти):</p>

<p><table border="1"><tr><td bgcolor="white">
<font face="Courier New"><pre>
; Для memtest.sch
org 0h

const start_address    2000h
const increment        2Dh
const max_address_msb  40h

:start
xra   a
out   0h
lxi   h, start_address

:loop
xra   a

:inner
mov   m, a
cmp   m
jnz   error

adi   increment
jnc   inner

inx   h
mov   a, l
out   00h
mov   a, h
cpi   max_address_msb

jnz   loop
jmp   start

:error
dcr   a
out   00h
jmp   error
</pre></font></td></tr></table>
</p>


</body>
</html>

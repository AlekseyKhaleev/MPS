<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
  <title></title>
  <meta name="description" content="">
  <meta name="keywords" content="">
  <meta name="author" content="VAN">
  <meta name="generator" content="Quanta Plus">
</head>
<body>

<a name="memtest"></a>
<h1>5.2. Тест памяти (memtest.sch)</h1>

<p style="text-align: justify">С помощью схемы на базе процессора Intel 8080 можно 
протестировать один из добавленных модулей памяти (ОЗУ 8K), проверить работу 
некоторых инструкций процессора, работу системного контроллера, простого регистра 
и генератора двух тактовых последовательностей.
</p>

<p>Схема выглядит так:</p>

<img src="images/samples/image001.png" width="876" height="561" alt="" border="0">

<p>На схеме присутствуют элементы:</p>

<ol>
<li>Процессор (DD1). Выполняет программу тестирования одного из модулей памяти (DD4). Программа считывается из DD3;</li>
<li>Память – два модуля по 8К (DD3, DD4);</li>
<li>Системный контроллер ВК28 (DD2) – служит для выработки управляющих сигналов;</li>
<li>Генератор двух тактовых последовательностей – служит для получения последовательностей F1 и F2 для процессора;</li>
<li>Регистр с параллельной загрузкой (DD10). Играет роль порта вывода для отображения процесса тестирования или состояния «найдена ошибка»;</li> 
<li>Два индикатора для отображения;</li>
<li>Логические элементы для формирования управляющих сигналов (DD3-DD8);</li>
<li>Блок переключателей.</li>
</ol> 

<p style="text-align: justify">Схему можно собрать, последовательно добавляя элементы из соответствующих модулей и соединяя их с помощью шин.</p>

<p style="text-align: justify">На этой схеме можно настроить многие параметры для разных элементов. 
Например, при щелчке правой кнопкой на УГО генератора появится окно следующего вида:
</p>

<div style="text-align: center"><img src="images/samples/image003.png" width="389" height="314" alt="" border="0"></div>

<p style="text-align: justify">Это окно было сформировано ядром программы. Модуль, в котором определен 
генератор, только предоставил список настраиваемых свойств. Такого рода 
возможности предоставляет новый улучшенный интерфейс для подключаемых модулей.
</p>
 
<p style="text-align: justify">Аналогичным образом можно вызвать окна настройки для других 
элементов. Для процессора вызывается окно отладчика, в 
котором присутствует и дизассемблер:
</p>

<img src="images/samples/image005.png" width="588" height="310" alt="" border="0">

<p style="text-align: justify">В данной схеме модуль памяти DD3 отображается на адреса 0000h-1FFFh, 
а модуль DD4 – на 2000-3FFFh. Регистр предназначен для вывода и имеет адрес порта 00h. 
</p>
 
<p style="text-align: justify">При тестировании процессор последовательно перебирает байты 
с адресами от 2000h до 3FFFh, записывая в каждый значения 
от 00h с шагом 2Dh (до переполнения аккумулятора). В идеале 
лучше взять шаг, равный единице, однако такое тестирование будет 
выполняться в программе очень долго. При нормальном тестировании 
на индикаторах отображается младший байт текущего адреса (т.е. 
значение регистра L). Это значение постоянно увеличивается 
(естественно, с «наматыванием» при переполнении) При обнаружении 
ошибки на индикаторах отображается уменьшающееся значение.
</p>

<p>Процессор выполняет программу следующего вида:</p>

<table border="2" bgcolor="white">
<tr><td>Адрес</td><td>Мнемоника</td><td>Комментарий</td></tr>
<tr><td>0000h</td>
<td>XRA A</td>
<td>Очищаем аккумулятор для вывода</td></tr>
 
<tr>
<td>0001h</td>
<td>OUT 00h</td>
<td>Вывод полученного нулевого байта в порт 0 (т.е. на индикаторы)</td>
</tr> 

<tr><td>0003h</td>
<td>LXI H, 2000h</td>
<td>Загрузка начального адреса модуля для тестирования</td>
</tr> 

<tr><td>0006h</td>
<td>XRA A</td>
<td>Очистка аккумулятора. Выполняется в цикле</td>
</tr> 

<tr><td>0007h</td>
<td>MOV M, A</td>
<td>Записываем содержимое аккумулятора в текущий байт памяти</td>
</tr> 

<tr><td>0008h</td>
<td>CMP M</td>
<td>Сравниваем записанное значение со значением аккумулятора</td>
</tr> 

<tr><td>0009h</td>
<td>JNZ 0020h</td>
<td>Если значения не совпадают, переходим к отображению на индикаторах циклически 
уменьшающегося значения (от FFh к 00h и затем снова к FFh). При нормальном 
тестировании на индикаторах отображаются возрастающие значения</td>
</tr> 

<tr><td>000Ch</td>
<td>ADI 2Dh</td>
<td>Добавим к аккумулятору значение 2Dh</td>
</tr> 

<tr><td>000Eh</td>
<td>JNC 0007h</td>
<td>Если переполнения нет, запишем байт из аккумулятора по тому же адресу еще раз…</td>
</tr> 

<tr><td>0011h</td>
<td>INX H</td>
<td>Перейдем к следующему байту</td>
</tr> 

<tr><td>0012h</td>
<td>MOV A, L</td>
<td>Загрузим в аккумулятор байт из L</td>
</tr> 

<tr><td>0013h</td>
<td>OUT 00h</td>
<td>Выведем текущее значение L на индикаторы</td>
</tr> 

<tr><td>0015h</td>
<td>MOV A, H</td>
<td>Загрузим в аккумулятор байт из H</td>
</tr> 

<tr><td>0016h</td>
<td>CPI 40h</td>
<td>Если старший байт адреса достиг 40h, мы подошли к концу модуля памяти</td></tr>
 
<tr><td>0018h</td>
<td>JNZ 0006h</td>
<td>Если нет, то перейдем к тестированию нового байта</td>
</tr> 

<tr><td>001Bh</td>
<td>JMP 0000h</td>
<td>Если да, то начнем все сначала</td>
</tr> 

<tr><td>0020h</td>
<td>DCR A</td>
<td>Уменьшим A на 1</td>
</tr> 

<tr><td>0021h</td>
<td>OUT 00h</td>
<td>Выведем на индикаторы</td>
</tr> 

<tr>
<td>0023h</td>
<td>JMP 0020h</td>
<td>Перейдем к 0020h</td>
</tr> 
</table>

<p style="text-align: justify">При проверке работы на индикаторы выдается постоянно 
увеличивающееся значение (с наматыванием, естественно). 
Это означает, что память работоспособна (во всяком случае, 
этот тест ошибок не выявил). 
</p>

<p style="text-align: justify">Если изменить инструкцию по адресу 0009h на JZ 0020h (код CA, 20, 00), 
на индикаторы выводятся уменьшающиеся значения, как это и должно быть.
</p>

</body>
</html>

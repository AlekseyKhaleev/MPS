; УГО внешнего 16-разрядного АЛУ
; АЛУ работает как внешнее устройство и может управляться
; через порты ввода/вывода или отображаться на адреса памяти
; (последнее намного удобнее)
; Имеет входы адреса (3 разряда), данных (8 разрядов, двунаправленные), RD, WR, CS, CLK,
; выход готовности RDY
; Может осуществлять параллельно вычисления и ввод/вывод

; Адреса и соответствующие им регистры:

; Адрес      Регистр вывода            Регистр ввода (если отличается)
; 000        Младший байт ACC
; 001        Старший байт ACC
; 010        Младший байт RG1
; 011        Старший байт RG1
; 100        Младший байт RG2
; 101        Старший байт RG2
; 110        Выполняемая команда       Регистр состояния
; 111        Дополнительные команды    При чтении выводится ноль

; ACC - аккумулятор. Результаты помещаются сюда
; Для выполнения команды нужно вывести ее код в регистр CMD (адрес 100) 
; в формате (битовое поле):
; cmd (4 бита) r1 (2 бита) r2 (2 бита)
; cmd кодирует операцию, (кроме mov и xchg), r1 и r2 - операнды
; 00  ACC
; 01  RG1
; 10  RG2
; 11  Ноль
; Результат может быть помещен в ACC

; В следующей таблице r1 и r2 означают первый и второй операнды
; Коды команд (bin, hex)    Смысл         Время 
; 0000, 0x0                 cmp           2       (Вычесть r2 из r1 и установить флаги)
; 0001, 0x1                 add           2       (acc = r1 + r2)
; 0010, 0x2                 sub           2       (acc = r1 - r2)
; 0011, 0x3                 mul           8       (rg1:acc = r1 * r2) - беззнаковое умножение
; 0100, 0x4                 div           16      (acc = r1 / r2, rg1 = r1 mod r2) - беззнаковое деление
; 0101, 0x5                 imul          8       (rg1:acc = r1 * r2) - знаковое умножение
; 0110, 0x6                 idiv          16      (acc = r1 / r2, rg1 = r1 mod r2) - знаковое деление
; 0111, 0x7                 adc           2       (acc = r1 + r2 + флаг переноса)
; 1000, 0x8                 sbb           2       (acc = r1 - r2 - флаг переноса)   
; 1001, 0x9                 mov           2       (r1 = r2)
; 1010, 0xA                 neg           2       (r1 = -r2) 
; 1011, 0xB                 xch           4       (обмен r1 и r2)
; 1100, 0xC                 and           2       (acc = r1 & r2) 
; 1101, 0xD                 or            2       (acc = r1 | r2)
; 1110, 0xE                 xor           2       (acc = r1 ^ r2) 
; 1111, 0xF                 not           2       (r1 = !r2)

; Дополнительные команды (в регистре 101b)
; 0000, 0x0                 cbw           2       (расширить младший байт r1 до слова знаковым битом)  
; 0001, 0x1                 zbw           2       (очистить старший байт r1) 
; 0010, 0x2                 clr           2       (обнулить r1) 
; 1111, 0xF                 nop           0       (никаких действий)

; Регистр состояния содержит следующие флаги:
; D0       Перенос
; D1       Переполнение (в т.ч. при делении на ноль)
; D2       Результат отрицательный (знаковый бит установлен)
; D3       Результат равен нулю 
; D4       Последняя команда была некорректной

; Соответствующие флаги устанавливаются всеми командами (даже mov), 
; кроме xchg, которая флаги не меняет

[options]
label = ALU
leftpins = 8
rightpins = 13
leftalign = up

[left0]
name = A2
kind = in

[left1]
name = A1
kind = in

[left2]
name = A0
kind = in

[left3]
kind = separator

[left4]
name = RD
kind = in
mark = inverse

[left5]
name = WR
kind = in
mark = inverse

[left6]
name = CS
kind = in
mark = inverse

[left7]
name = CLK
kind = in
mark = front-lh

[left8]
name = RDY
kind = out

[right0]
kind = zlevels

[right1]
kind = bidirarrow

[right2]
kind = space

[right3]
name = D7
kind = in

[right4]
name = D6
kind = in

[right5]
name = D5
kind = in

[right6]
name = D4
kind = in 

[right7]
name = D3
kind = in

[right8]
name = D2
kind = in

[right9]
name = D1
kind = in

[right10]
name = D0
kind = in

[right11]
kind = separator

[right12]
name = RDY
kind = out